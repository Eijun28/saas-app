name: Auto-Merge PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ["*"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    name: Auto-merge PR
    runs-on: ubuntu-latest
    # Only run on PRs with the 'auto-merge' label OR Dependabot PRs
    if: |
      github.event_name == 'pull_request' &&
      (
        contains(github.event.pull_request.labels.*.name, 'auto-merge') ||
        github.actor == 'dependabot[bot]'
      )
    steps:
      - name: Wait for checks to pass
        uses: lewagon/wait-on-check-action@v1.3.4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          running-workflow-name: "Auto-merge PR"
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success,skipped

      - name: Merge PR (squash)
        uses: pascalgn/automerge-action@v0.16.4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          MERGE_METHOD: squash
          MERGE_COMMIT_MESSAGE: "{pullRequest.title} (#{pullRequest.number})"
          MERGE_DELETE_BRANCH: true
          MERGE_RETRIES: 6
          MERGE_RETRY_SLEEP: 10000
          UPDATE_METHOD: rebase

  # Separate job: trigger auto-merge when all checks complete on a PR
  trigger-on-checks:
    name: Trigger auto-merge on check completion
    runs-on: ubuntu-latest
    if: github.event_name == 'check_suite' && github.event.check_suite.conclusion == 'success'
    steps:
      - name: Find associated PRs and auto-merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: context.payload.check_suite.head_branch,
            });

            for (const pr of prs) {
              const labels = pr.labels.map(l => l.name);
              const isAutoMerge = labels.includes('auto-merge');
              const isDependabot = pr.user.login === 'dependabot[bot]';

              if (!isAutoMerge && !isDependabot) continue;

              // Check all required checks pass
              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha,
              });

              const allPassed = checks.check_runs.every(
                c => c.status === 'completed' && ['success', 'skipped', 'neutral'].includes(c.conclusion)
              );

              if (!allPassed) {
                console.log(`PR #${pr.number}: checks not all passed, skipping.`);
                continue;
              }

              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: pr.number,
                  merge_method: 'squash',
                  commit_title: `${pr.title} (#${pr.number})`,
                });
                console.log(`PR #${pr.number} merged successfully.`);

                // Delete the branch after merge
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${pr.head.ref}`,
                  });
                  console.log(`Branch ${pr.head.ref} deleted.`);
                } catch (e) {
                  console.log(`Could not delete branch: ${e.message}`);
                }
              } catch (e) {
                console.log(`Could not merge PR #${pr.number}: ${e.message}`);
              }
            }
